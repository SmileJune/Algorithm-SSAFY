package com.ssafy.an;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Day98BOJ2293동전1DP수정 { // 2293 동전1 DP 2차원으로
	static int N, K;
	static int[] arr;
	static Integer[][] dp;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] str = br.readLine().split(" ");
		N = Integer.parseInt(str[0]);
		K = Integer.parseInt(str[1]);

		arr = new int[N + 1];
		for (int i = 1; i < N + 1; i++)
			arr[i] = Integer.parseInt(br.readLine());
		dp = new Integer[N + 1][K + 1];

		System.out.println(recur(N, K));
//		for (int i = 0; i < N + 1; i++)
//			System.out.println(i + " :: " + Arrays.toString(dp[i]).replaceAll("[\\[\\],ull]", ""));
		br.close();
	}

	private static int recur(int n, int k) {
		if (n == 0)
			return dp[n][k] = 0;
		if (k == 0)
			return dp[n][k] = 1;
		if (dp[n][k] == null) {
			dp[n][k] = 0;
			for (int i = 0; i < n + 1; i++)
				if (k - arr[i] >= 0)
					dp[n][k] += recur(i, k - arr[i]);
		}
		return dp[n][k];
	}
}
// 0 1 2 3 4 5 6 7 8 9 10
// 1 1 1 1 1 1 1 1 1(1)1
// 1 1 2 2 3 3 4 4(5)5 6
// 1 1 2 2 3(4)5 6 7 8 10 << dp[3][10] = dp[1][9] + dp[2][8] + dp[3][5]
// 기억 났다.. 동전을 만드는 경우의 수가 아니라
// 맨 뒤에 동전을 붙혀 나머지를 채우는 경우의 수임..
// 단, 내가 맨 뒤에 붙을 때 나보다 큰 수 뒤에는 못붙음.(작은 동전부터 사용하여 중복회피, 정렬되었다고 생각) ★★★
// 1 : 1
// 2 : 11          | 2 
// 3 : 111         | 12
// 4 : 1111        | 112         22 
// 5 : 11111       | 1112        122                                         | 5 <
// 6 : 111111      | 11112       1122       222                              | 15
// 7 : 1111111     | 111112      11122      1222                             | 115      25
// 8 : 11111111    | 1111112     111122     11222     2222 <                 | 1115     125
// 9 : 111111111 < | 11111112    1111122    111222    12222                  | 11115    1125    225
//10 > 1111111111  | 111111112   11111122   1111222   112222   22222         | 111115   11125   1225                55 <
//11 : 11111111111 | 1111111112  111111122  11111222  1112222  122222        | 1111115  111125  11225   2225        155
//12 : 111111111111| 11111111112 1111111122 111111222 11112222 1122222 222222| 11111115 1111125 1111225 12225 22225 1155 255 
//----- dp[9] + 1원|--------------------------------------------- dp[8] + 2원| --------------------------------- dp[5] + 5원
//1원짜리를 사용 하기때문에 모든 배열이 1단씩 커짐
//2원짜리 때문에 2원부터 짝수번째마다 경우의 수가 1개씩 추가 (왜냐 22, 222, 2222가 붙기 때문에)
//5원짜리 때문에 5원부터 5의 배수 마다 1과 2로 만드는 경우의 수 개 만큼 추가
//10을 만드는 방법
//5 : 11111      1112      122                   5  여기에 5원을 붙히는 경우의 수 즉, 4개*1            
//8 : 11111111   1111112   111122   11222   2222    여기에 2원을 붙히는 경우의 수 5개*1
//9 : 111111111                                     여기게 1원을 붙히는 경우의 수 1개*1
//-------
//3을 만드는 방법
//1 : 1  여기에 2를 붙히는 경우의 수 1개 * 1
//2 : 11 여기에 1을 붙히는 경우의 수 1개 * 1        
//-------
//7을 만드는 방법
//2 : 11         2                +5 2개
//5 : 11111      1112      122    +2 3개
//6 : 111111                      +1 1개  
//----------------
//1원 없이  2원 과 3원으로 금액을 만드는 경우
//1 : 
//2 : 2
//3 :           3
//4 : 22
//5 :           23
//6 : 222                33 
//7 :           223
//8 : 2222               233
//9 :           2223              333
//10 : 22222              2233
//11 :           22223             2333 
//12 : 222222             22233            3333 
//13 :           222223            22333
//14 : 2222222            222233           23333
//15 :           2222223           222333            33333
//16 : 22222222           2222233          223333
//17 :           22222223          2222333           233333
//18 : 222222222          22222233         2223333          333333 
//------
//18을 만드는 경우의 수는
//16 : 22222222 에 2원을 붙히는 경우 1개(3원 뒤에는 붙히지 않는다.)
//15 : 2222223 222333 33333 에 3원을 붙히는 경우 3개 총 4개 